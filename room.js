// Generated by CoffeeScript 1.8.0
(function() {
  var Ball, Vx0, Vy0, Wall, all_balls, all_walls, animate, canvas, check_balls_collision, context, get_distance, height, init_balls, init_walls, paused, r, random_ball, random_balls, random_hex_color, random_hor_wall, random_int, random_vert_wall, random_walls, render, step, update, wall_length0, wall_thickness0, wedge_product, width, x0, y0, _ref, _ref1;

  r = 10;

  _ref = [300, 600], x0 = _ref[0], y0 = _ref[1];

  _ref1 = [7, 12], Vx0 = _ref1[0], Vy0 = _ref1[1];

  wall_length0 = 280;

  wall_thickness0 = 5;

  width = window.innerWidth - 15;

  height = window.innerHeight - 130;

  canvas = document.createElement("canvas");

  canvas.width = width;

  canvas.height = height;

  context = canvas.getContext("2d");

  random_int = function(l, u) {
    var _ref2;
    if (l > u) {
      _ref2 = [u, l], l = _ref2[0], u = _ref2[1];
    }
    return Math.floor(Math.random() * (u - l + 1) + l);
  };

  random_hex_color = function(len) {
    var patt, str, _i;
    if (len == null) {
      len = 6;
    }
    patt = '0123456789ABCDEF'.split('');
    str = '#';
    for (_i = 1; 1 <= len ? _i <= len : _i >= len; 1 <= len ? _i++ : _i--) {
      str += patt[random_int(0, patt.length - 1)];
    }
    return str;
  };

  wedge_product = function(xA, yA, xB, yB) {
    return xA * yB - xB * yA;
  };

  get_distance = function(dx, dy) {
    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
  };

  Ball = function(x, y, Vx, Vy, radius, color) {
    if (radius == null) {
      radius = r;
    }
    if (color == null) {
      color = '#000000';
    }
    this.x = x;
    this.y = y;
    this.vel = {
      x: Vx,
      y: Vy
    };
    this.vel.length = get_distance(this.vel.x, this.vel.y);
    this.radius = radius;
    this.color = color;
    return this.mass = this.radius;
  };

  random_ball = function() {
    return new Ball(random_int(100, width - 200), random_int(100, height - 200), random_int(5, 10), random_int(5, 10), r, random_hex_color());
  };

  random_balls = function(n) {
    var _i, _results;
    if (n == null) {
      n = 2;
    }
    _results = [];
    for (_i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--) {
      _results.push(random_ball());
    }
    return _results;
  };

  Wall = function(x, y, wall_width, wall_height) {
    this.x = x;
    this.y = y;
    this.width = wall_width;
    return this.height = wall_height;
  };

  Wall.prototype.render = function() {
    context.fillStyle = "#000000";
    return context.fillRect(this.x, this.y, this.width, this.height);
  };

  random_vert_wall = function() {
    return new Wall(random_int(100, width - 200), random_int(100, height - 200), wall_thickness0, random_int(100, 300));
  };

  random_hor_wall = function() {
    return new Wall(random_int(100, width - 200), random_int(100, height - 200), random_int(100, 300), wall_thickness0);
  };

  random_walls = function(nHor, nVert) {
    var hors, verts;
    if (nHor == null) {
      nHor = 2;
    }
    if (nVert == null) {
      nVert = 2;
    }
    verts = (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= nVert ? _i <= nVert : _i >= nVert; 1 <= nVert ? _i++ : _i--) {
        _results.push(random_vert_wall());
      }
      return _results;
    })();
    hors = (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= nHor ? _i <= nHor : _i >= nHor; 1 <= nHor ? _i++ : _i--) {
        _results.push(random_hor_wall());
      }
      return _results;
    })();
    return hors.concat(verts);
  };

  check_balls_collision = function(B1, B2) {
    var angle, angle1, angle2, dx, dy, u1, u1x, u1y, u2, u2x, u2y, v1, v1x, v1y, v2, v2x, v2y;
    dx = B1.x - B2.x;
    dy = B1.y - B2.y;
    if (get_distance(dx, dy) > B1.radius + B2.radius) {
      return;
    }
    angle = Math.atan2(dy, dx);
    u1 = B1.vel;
    u2 = B2.vel;
    angle1 = Math.atan2(u1.y, u1.x);
    angle2 = Math.atan2(u2.y, u2.x);
    u1x = u1.length * Math.cos(angle1 - angle);
    u1y = u1.length * Math.sin(angle1 - angle);
    u2x = u2.length * Math.cos(angle2 - angle);
    u2y = u2.length * Math.sin(angle2 - angle);
    v1x = ((B1.mass - B2.mass) * u1x + (B2.mass + B2.mass) * u2x) / (B1.mass + B2.mass);
    v2x = ((B1.mass + B1.mass) * u1x + (B2.mass - B1.mass) * u2x) / (B1.mass + B2.mass);
    v1y = u1y;
    v2y = u2y;
    v1 = {};
    v2 = {};
    v1.x = Math.cos(angle) * v1x + Math.cos(angle + Math.PI / 2) * v1y;
    v1.y = Math.sin(angle) * v1x + Math.sin(angle + Math.PI / 2) * v1y;
    v1.length = get_distance(v1.x, v1.y);
    v2.x = Math.cos(angle) * v2x + Math.cos(angle + Math.PI / 2) * v2y;
    v2.y = Math.sin(angle) * v2x + Math.sin(angle + Math.PI / 2) * v2y;
    v2.length = get_distance(v2.x, v2.y);
    B1.vel = v1;
    return B2.vel = v2;
  };

  Ball.prototype.check_sides_collision = function() {
    if (this.x < r) {
      this.x = r;
      return this.vel.x = -this.vel.x;
    } else if (this.x > width - r) {
      this.x = width - r;
      return this.vel.x = -this.vel.x;
    } else if (this.y < r) {
      this.y = r;
      return this.vel.y = -this.vel.y;
    } else if (this.y > height - r) {
      this.y = height - r;
      return this.vel.y = -this.vel.y;
    }
  };

  Ball.prototype.check_walls_collision = function(walls) {
    var wall, wpHor, wpVert, _i, _len, _ref2, _ref3, _ref4, _ref5, _results;
    _results = [];
    for (_i = 0, _len = walls.length; _i < _len; _i++) {
      wall = walls[_i];
      if (wall.width === wall_thickness0) {
        wpVert = wedge_product(0, -wall.height, this.x - wall.x, this.y - (wall.y + wall.height));
        if (wpVert <= 0 && ((wall.y - r < (_ref2 = this.y) && _ref2 < wall.y + wall.height + r)) && this.x + r > wall.x) {
          this.x = wall.x - r;
          this.vel.x = -this.vel.x;
        } else if (wpVert > 0 && ((wall.y - r < (_ref3 = this.y) && _ref3 < wall.y + wall.height + r)) && this.x - r < wall.x + wall.width) {
          this.x = wall.x + wall.width + r;
          this.vel.x = -this.vel.x;
        }
      } else {

      }
      if (wall.height === wall_thickness0) {
        wpHor = wedge_product(wall.width, 0, this.x - wall.x, this.y - wall.y);
        if (wpHor <= 0 && ((wall.x - r < (_ref4 = this.x) && _ref4 < wall.x + wall.width + r)) && this.y + r > wall.y) {
          this.y = wall.y - r;
          _results.push(this.vel.y = -this.vel.y);
        } else if (wpHor > 0 && ((wall.x - r < (_ref5 = this.x) && _ref5 < wall.x + wall.width + r)) && this.y - r < wall.y + wall.height) {
          this.y = wall.y + wall.height + r;
          _results.push(this.vel.y = -this.vel.y);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Ball.prototype.render = function() {
    context.beginPath();
    context.arc(this.x, this.y, this.radius, 2 * Math.PI, false);
    context.fillStyle = this.color;
    return context.fill();
  };

  Ball.prototype.update = function() {
    this.x += this.vel.x;
    this.y += this.vel.y;
    this.check_sides_collision();
    return this.check_walls_collision(all_walls);
  };

  context.fillStyle = "#008800";

  context.fillRect(0, 0, width, height);

  render = function() {
    var ball, wall, _i, _j, _len, _len1, _results;
    context.fillStyle = "#008800";
    context.fillRect(0, 0, width, height);
    for (_i = 0, _len = all_balls.length; _i < _len; _i++) {
      ball = all_balls[_i];
      ball.render();
    }
    _results = [];
    for (_j = 0, _len1 = all_walls.length; _j < _len1; _j++) {
      wall = all_walls[_j];
      _results.push(wall.render());
    }
    return _results;
  };

  paused = false;

  update = function() {
    var i, j, _results;
    if (!paused) {
      i = 0;
      _results = [];
      while (i < all_balls.length) {
        all_balls[i].update();
        j = i + 1;
        while (j < all_balls.length) {
          check_balls_collision(all_balls[i], all_balls[j]);
          j++;
        }
        _results.push(i++);
      }
      return _results;
    }
  };

  all_balls = [];

  all_walls = [];

  init_balls = function() {
    var ball, _i, _len, _results;
    all_balls = all_balls.concat(random_balls());
    _results = [];
    for (_i = 0, _len = all_balls.length; _i < _len; _i++) {
      ball = all_balls[_i];
      _results.push(ball.render());
    }
    return _results;
  };

  init_walls = function() {
    var wall, _i, _len, _results;
    all_walls = all_walls.concat(random_walls());
    _results = [];
    for (_i = 0, _len = all_walls.length; _i < _len; _i++) {
      wall = all_walls[_i];
      _results.push(wall.render());
    }
    return _results;
  };

  animate = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 100 / 60);
  };

  window.onload = function() {
    document.body.appendChild(canvas);
    document.getElementById('addRndWallsBtn').onclick = function() {
      return init_walls();
    };
    document.getElementById('addRndBallsBtn').onclick = function() {
      return init_balls();
    };
    document.getElementById('startBtn').onclick = function() {
      return animate(step);
    };
    return document.getElementById('pauseBtn').onclick = function() {
      return paused = !paused;
    };
  };

  step = function() {
    update();
    render();
    return animate(step);
  };

}).call(this);
