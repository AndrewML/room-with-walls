// Generated by CoffeeScript 1.8.0
(function() {
  var Ball, Wall, all_balls, all_walls, animate, ball, canvas, context, height, putRandomBalls, putRandomWalls, r, randomHexColor, randomInt, render, step, update, wall_length0, wall_thickness0, wedge_product, width, x0, x_speed0, y0, y_speed0;

  r = 100;

  x0 = 100;

  y0 = 100;

  x_speed0 = 12;

  y_speed0 = 7;

  wall_length0 = 280;

  wall_thickness0 = 5;

  width = window.innerWidth - 20;

  height = window.innerHeight - 20;

  canvas = document.createElement("canvas");

  canvas.width = width;

  canvas.height = height;

  context = canvas.getContext("2d");

  randomInt = function(l, u) {
    var _ref;
    if (l > u) {
      _ref = [u, l], l = _ref[0], u = _ref[1];
    }
    return Math.floor(Math.random() * (u - l + 1) + l);
  };

  randomHexColor = function(len) {
    var pattern, str, _i;
    if (len == null) {
      len = 6;
    }
    pattern = '0123456789ABCDEF'.split('');
    str = '#';
    for (_i = 1; 1 <= len ? _i <= len : _i >= len; 1 <= len ? _i++ : _i--) {
      str += pattern[randomInt(0, pattern.length - 1)];
    }
    return str;
  };

  putRandomWalls = function(nHor, nVert) {
    var hors, verts;
    if (nHor == null) {
      nHor = 5;
    }
    if (nVert == null) {
      nVert = 5;
    }
    hors = (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= nHor ? _i <= nHor : _i >= nHor; 1 <= nHor ? _i++ : _i--) {
        _results.push(new Wall(randomInt(100, width - 100), randomInt(100, height - 100), wall_thickness0, randomInt(100, 300)));
      }
      return _results;
    })();
    verts = (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= nVert ? _i <= nVert : _i >= nVert; 1 <= nVert ? _i++ : _i--) {
        _results.push(new Wall(randomInt(100, width - 100), randomInt(100, height - 100), randomInt(100, 300), wall_thickness0));
      }
      return _results;
    })();
    return hors.concat(verts);
  };

  putRandomBalls = function(n) {
    var _i, _results;
    if (n == null) {
      n = 3;
    }
    _results = [];
    for (_i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--) {
      _results.push(new Ball(randomInt(100, width - 100), randomInt(100, height - 100), randomHexColor()));
    }
    return _results;
  };

  wedge_product = function(xA, yA, xB, yB) {
    return xA * yB - xB * yA;
  };

  Ball = function(x, y, color) {
    this.x = x;
    this.y = y;
    this.x_speed = x_speed0;
    this.y_speed = y_speed0;
    this.radius = r;
    return this.color = color;
  };

  Wall = function(x, y, wall_width, wall_height) {
    this.x = x;
    this.y = y;
    this.width = wall_width;
    return this.height = wall_height;
  };

  ball = new Ball(x0, y0);

  all_balls = putRandomBalls(2);

  all_walls = [];

  Ball.prototype.render = function() {
    context.beginPath();
    context.arc(this.x, this.y, this.radius, 2 * Math.PI, false);
    context.fillStyle = this.color;
    return context.fill();
  };

  Ball.prototype.case_sides_collision = function() {
    if (this.x < r) {
      this.x = r;
      return this.x_speed = -this.x_speed;
    } else if (this.x > width - r) {
      this.x = width - r;
      return this.x_speed = -this.x_speed;
    } else if (this.y < r) {
      this.y = r;
      return this.y_speed = -this.y_speed;
    } else if (this.y > height - r) {
      this.y = height - r;
      return this.y_speed = -this.y_speed;
    }
  };

  Ball.prototype.case_walls_collision = function(walls) {
    var wall, wpHor, wpVert, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
    _results = [];
    for (_i = 0, _len = walls.length; _i < _len; _i++) {
      wall = walls[_i];
      if (wall.width === wall_thickness0) {
        wpVert = wedge_product(0, -wall.height, this.x - wall.x, this.y - (wall.y + wall.height));
        if (wpVert <= 0 && ((wall.y - r < (_ref = this.y) && _ref < wall.y + wall.height + r)) && this.x + r > wall.x) {
          this.x = wall.x - r;
          this.x_speed = -this.x_speed;
        } else if (wpVert > 0 && ((wall.y - r < (_ref1 = this.y) && _ref1 < wall.y + wall.height + r)) && this.x - r < wall.x + wall.width) {
          this.x = wall.x + wall.width + r;
          this.x_speed = -this.x_speed;
        }
      } else {

      }
      if (wall.height === wall_thickness0) {
        wpHor = wedge_product(wall.width, 0, this.x - wall.x, this.y - wall.y);
        if (wpHor <= 0 && ((wall.x - r < (_ref2 = this.x) && _ref2 < wall.x + wall.width + r)) && this.y + r > wall.y) {
          this.y = wall.y - r;
          _results.push(this.y_speed = -this.y_speed);
        } else if (wpHor > 0 && ((wall.x - r < (_ref3 = this.x) && _ref3 < wall.x + wall.width + r)) && this.y - r < wall.y + wall.height) {
          this.y = wall.y + wall.height + r;
          _results.push(this.y_speed = -this.y_speed);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Ball.prototype.update = function() {
    this.x += this.x_speed;
    this.y += this.y_speed;
    this.case_sides_collision();
    return this.case_walls_collision(all_walls);
  };

  Wall.prototype.render = function() {
    context.fillStyle = "#000000";
    return context.fillRect(this.x, this.y, this.width, this.height);
  };

  render = function() {
    var wall, _i, _j, _len, _len1, _results;
    context.fillStyle = "#008800";
    context.fillRect(0, 0, width, height);
    for (_i = 0, _len = all_walls.length; _i < _len; _i++) {
      wall = all_walls[_i];
      wall.render();
    }
    _results = [];
    for (_j = 0, _len1 = all_balls.length; _j < _len1; _j++) {
      ball = all_balls[_j];
      _results.push(ball.render());
    }
    return _results;
  };

  update = function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = all_balls.length; _i < _len; _i++) {
      ball = all_balls[_i];
      _results.push(ball.update());
    }
    return _results;
  };

  animate = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 100);
  };

  window.onload = function() {
    document.body.appendChild(canvas);
    return animate(step);
  };

  step = function() {
    update();
    render();
    return animate(step);
  };

}).call(this);
